---
linkTitle: Half Big RSA
title: Half Big RSA [Writeup]
type: docs
math: True
weight: 4
---
## Challenge Description


> Prime numbers are the best numbers. So, you should let me use it for my modulus!

## Challenge Files

```python {filename=main.py, linenos=table}
import math
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes
import os

num_bits = 4096
e = (num_bits - 1) * 2
n = getPrime(num_bits)

with open("flag.txt","rb") as f:
    flag = f.read()

m = bytes_to_long(flag)
c = pow(m, e, n)
print(c)

with open("output.txt", "w") as f:
	f.write("e = {0}\n".format(e))
	f.write("n = {0}\n".format(n))
	f.write("c = {0}\n".format(c))

```
and an output file
```
e = 8190
n = 665515140120452927777672138241759151799589898667434054796291409500701895847040006534274017960741836352283431369658890777476904763064058571375981053480910502427450807868148119447222740298374306206049235106218160749784482387828757815767617741823504974133549502118215185814010416478030136723860862951197024098473528800567738616891653602341160421661595097849964546693006026643728700179973443277934626276981932233698776098859924467510432829393769296526806379126056800758440081227444482951121929701346253100245589361047368821670154633942361108165230244033981429882740588739029933170447051711603248745453079617578876855903762290177883331643511001037754039634053638415842161488684352411211039226087704872112150157895613933727056811203840732191351328849682321511563621522716119495446110146905479764695844458698466998084615534512596477826922686638159998900511018901148179784868970554998882571043992165232556707995154316126421679595109794273650628957795546293370644405017478289280584942868678139801608538607476925924119532501884957937405840470383051787503858934204828174270819328204062103187487600845013162433295862838022726861622054871029319807982173856563380230936757321006235403066943155942418392650327854150659087958008526462507871976852849
c = 264114212766855887600460174907562771340758069941557124363722491581842654823497784410492438939051339540245832405381141754278713030596144467650101730615738854984455449696059994199389876326336906564161058000092717176985620153104965134542134700679600848779222952402880980397293436788260885290623102864133359002377891663502745146147113128504592411055578896628007927185576133566973715082995833415452650323729270592804454136123997392505676446147317372361704725254801818246172431181257019336832814728581055512990705620667354025484563398894047211101124793076391121413112862668719178137133980477637559211419385463448196568615753499719509551081050176747554502163847399479890373976736263256211300138385881514853428005401803323639515624537818822552343927090465091651711036898847540315628282568055822817711675290278630405760056752122426935056309906683423667413310858931246301024309863011027878238814311176040130230980947128260455261157617039938807829728147629666415078365277247086868327600962627944218138488810350881273304037069779619294887634591633069936882854003264469618591009727405143494184122164870065700859379313470866957332849299246770925463579384528152251689152374836955250625216486799615834558624798907067202005564121699019508857929778460
```

## Solution

### Step One: Textbook RSA decryption
We need to solve RSA with a public exponent `e` that is not coprime to the euler totient of the public modulus. We can compute the gcd of `(e, phi(n))` and it turns out to be `18`. Therefore, we can compute `m ** (18)` using textbook RSA decryption
```python {filename=solve.py, linenos=table}
from Crypto.Util.number import *
from math import gcd

e = 8190
n = 665515140120452927777672138241759151799589898667434054796291409500701895847040006534274017960741836352283431369658890777476904763064058571375981053480910502427450807868148119447222740298374306206049235106218160749784482387828757815767617741823504974133549502118215185814010416478030136723860862951197024098473528800567738616891653602341160421661595097849964546693006026643728700179973443277934626276981932233698776098859924467510432829393769296526806379126056800758440081227444482951121929701346253100245589361047368821670154633942361108165230244033981429882740588739029933170447051711603248745453079617578876855903762290177883331643511001037754039634053638415842161488684352411211039226087704872112150157895613933727056811203840732191351328849682321511563621522716119495446110146905479764695844458698466998084615534512596477826922686638159998900511018901148179784868970554998882571043992165232556707995154316126421679595109794273650628957795546293370644405017478289280584942868678139801608538607476925924119532501884957937405840470383051787503858934204828174270819328204062103187487600845013162433295862838022726861622054871029319807982173856563380230936757321006235403066943155942418392650327854150659087958008526462507871976852849
c = 264114212766855887600460174907562771340758069941557124363722491581842654823497784410492438939051339540245832405381141754278713030596144467650101730615738854984455449696059994199389876326336906564161058000092717176985620153104965134542134700679600848779222952402880980397293436788260885290623102864133359002377891663502745146147113128504592411055578896628007927185576133566973715082995833415452650323729270592804454136123997392505676446147317372361704725254801818246172431181257019336832814728581055512990705620667354025484563398894047211101124793076391121413112862668719178137133980477637559211419385463448196568615753499719509551081050176747554502163847399479890373976736263256211300138385881514853428005401803323639515624537818822552343927090465091651711036898847540315628282568055822817711675290278630405760056752122426935056309906683423667413310858931246301024309863011027878238814311176040130230980947128260455261157617039938807829728147629666415078365277247086868327600962627944218138488810350881273304037069779619294887634591633069936882854003264469618591009727405143494184122164870065700859379313470866957332849299246770925463579384528152251689152374836955250625216486799615834558624798907067202005564121699019508857929778460

proof.arithmetic(False)

g = gcd(e, n - 1)
E = e // g

d = pow(E, -1, n - 1)
c = pow(c, d, n)

print(f"c^18: {c}")
```

### Step Two: Modular Square Roots and Cube Roots

Our goal is to extract `m` from `m ** (18)`. To do this, we could compute the modular square root of the obtained expression. This yields the roots of `m ** (18)`
```python 
from sage.all import *

proof.arithmetic(False)

c1 = Mod(c, n).sqrt()
c2 = n - c
```
Now we wish to compute the modular cube roots of the expression twice and that would give us the desired plaintext. Unfortunately, I couldn't find it implemented in sagemath and hence I had to rely on this snippet of code that I found on GitHub (to compute modular cube roots)

```python {filename=cbrt.py, linenos=table}
def cube_root(c, q):
    F = FiniteField(q)
    R.<x> = PolynomialRing(F,'x')
    while 1:
        a = F.random_element()
        b = F.random_element()
        fx = x**3 - a*x**2 + b*x - c
        fc = list(factor(fx))
        if len(fc) <= 1:
            root = pow(x, (q**2+q+1)//3, fx)
            root %= x
            return int(root)

def cube_roots(c,mod):
    c = c % mod
    rems = []
    if gcd( (mod-1), 3) == 1:
        d = inverse_mod(3, mod - 1)
        rems.append( int(pow(c, d, mod)) )
    else:
        g = GF(mod).multiplicative_generator()
        u = int(g ** ((mod-1)//3))
        r1 = int(cube_root(c, mod))
        for i in range(3):
            rems.append( int(r1 * pow(u, i, mod) % mod) )
    for m in rems :
        if pow(m,3,n) != c :
            print('%d = m^3 mod %d, m has no integer solutions.' % (c,n) )
            exit()
    return rems

c = 1003188979001593946418313345893840298277523760390307435096184733563370751625511051939981193965748283458964212281875100922959475813747216251919143026005678513842083751724887556565435603502360868686713175975026250813136174152046127265005679386885801567313169230305711373370032182333457089300428519515159690267799517457323512994799383320767969209750969775983129486291282594090839561275722671130737216137611504828799393253940503788460326893952612425634434943653620245686671213014313550570269916699906206716668856880654109948694356991211500183619181798378007136816174432473436323297572876215048195288520901186417045492434603630977004104070211756634700663528230901882024070347922225671618239126204846101226171496014785125

rems = cube_roots(c%n,n)
print(f"x = {rems}")

# ans = 10010618650440549435769034921537151709056664451401127804248153478123532800592285965118554911673113373513637743221155630020047767811834003397088776955001903266053395256978470128066145597397322772779412116205745594592179846799281751537575805

# print(long_to_bytes(ans))
```
and that gives us our flag

{{<callout type="info">}}
It's important to note here that, if $p \equiv 2 \pmod{3}$, then there exists a single and unique cube root. However, if $p \equiv 1 \pmod{3}$ then we could either have no cube roots or three cube roots. We already have two square roots and for each of them you would get nine cube roots (when applied twice) and hence a total of all the $18$ roots that we desired. You must test for the flag for each of these values.
{{</callout>}}
## Flag
```
bctf{Pr1M3_NUM83r5_4r3_C001_bu7_7H3Y_4r3_57r0N6_0N1Y_WH3N_7H3Y_4r3_MU171P113D_3V3N_1F_7H3Y_4r3_b1g}
```
