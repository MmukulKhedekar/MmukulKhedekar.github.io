---
title: Nullcon HackIM CTF Goa 2023 [Crypto Writeups]
date: 2023-08-22 00:00:00 +0530
categories: [CTF]
tags: [cryptography, crypto_writeups]
math: true
---
I participated in Nullcon HackIM CTF 2023 with the team <a href="https://ctftime.org/team/16691/">InfoSecIITR</a>. We finished $4$th out of the $397$ teams that participated in this competition. I'll explain the writeups for all the cryptography problems that were solved by our team. 
## Euclidean-RSA 
```
"Bob apparently likes squares, but what does it have to do with encryption?"
```

We are then provided with the following attachments <a href="/ignore/nullcon/euclidean-RSA.py">euclidean-RSA</a> and <a href="/ignore/nullcon/output.txt">output</a>

### Solution

the intended solution involved doing something with gaussian integers but i found a paper <a href="https://www.mdpi.com/2297-8747/25/4/63">here</a> that listed a really simple algorithm to do this. i implemented it and solved it
```python
from Cryptodome.Util.number import *
from math import gcd
from Cryptodome.Util.number import *

a = 139488614271687589953884690592970545345100917058745264617112217132329766542251923634602298183777415221556922931467521901793230800271771036880075840122128322419937786441619850848876309600263298041438727684373621920233326334840988865922273325440799379584418142760239470239003470212399313033715405566836809419407
b = 68334789534409058399709747444525414762334123566273125910569662060699644186162637240997793681284151882169786866201685085241431171760907057806355318216602175990235605823755224694383202043476486594392938995563562039702918509120988489287149220217082428193897933957628562633459049042920472531693730366503272507672
c = 124011822519139836919119491309637022805378274989854408578991029026928119002489232335977596528581855016599610031796540079373031282148998625318658034408770283112750172223328012238338715644743140990997114236125750813379366262418292349962679006556523851370694404238101553966330965676189731474108393418372330606063
d = 93529593432394381438671783119087013080855868893236377597950059020717371498802208966524066540234253992421963224344343067174201693672350438201011499762718490958025617655722916641293034417795512315497126128726644064013248230211347407788186320320456853993252621916838570027019607155835349111757703654306736031792
ct = 2819638499688340337879314536945338371611392232636746056275506290935131270682791584873534866138393305591899169164183372576878693678187335219904407119253951099126339949954303448641761723704171837075206394491403411400326176280981393624784437102905397888236098861970020785226848615566768625581096019917060387964269283048823007992992874533775547300443032304973521568046956516203101626941042560505073773998143068621715480774707735064134961852206070850277695448391038882766344567740211926618750074636868149063283746597347807257171871016202588384726430246523650462866812935130465049824665395626882280287488078029119879891722
n = (a**2+b**2)

x = a-c
y = d-b 

z = gcd(x,y)
x = x//z
y = y//z
p = x**2 + y**2
q = n//p
e = 65537

phi = (p-1)*(q-1)
d = pow(e,-1,phi)
print(long_to_bytes(pow(ct,d,n)))
```
```
ENO{Gauss_t0ld_u5_th3r3_1s_mor3_th4n_on3_d1men5i0n}
```
## Sebastian's Secret Sharing 
```
"I met Adi on a conference and decided to implement my own Secret Sharing Service.

It's pretty rudimentary, but gets the job done. Let's just hope, I didn't do anything wrong..."
```

We are then provided with the following attachment <a href="/ignore/nullcon/sss.py">sss</a> 

### Solution
if you observe carefully we are required to find `shares[0]` but we could directly receive that by sending in $ \text{sid} = n$ since they return the values `shares[sid%n]` to us 
```python
from Cryptodome.Util.number import *
x = 111370287875855598506538509804271500535681803123044982950094717
print(long_to_bytes(x))
```
```
ENO{SeCr3t_Sh4m1r_H4sh1ng}
```
## Curvy Decryptor
```
Alice has hidden 2 flags in this challenge. And even though she is willing to decrypt most ciphers, she has some basic saveguards against stealing flags.

Please submit flag1 here.
```
the challenge has two parts. we are provided with these attachments <a href="/ignore/nullcon/utils.py">utils</a>, <a href="/ignore/nullcon/ec.py">ec</a> and <a href="/ignore/nullcon/curvy_decryptor.py">curvy_decryptor</a>
### Solution
it's easy to observe that 

$$
    c = m + B \cdot d_a
$$

we are provided with the points $c$ and $B$ and to receive the first flag we'll have to retrieve the point $m$. we also have an arrangement that sends us the $x$-coordinate of the point $c-B\cdot d_a$. we could send in $2c$ and $2B$ and they'll return us the $x$-coordinate of the point $2m$. then we could retrieve the point $m$ from that using sagemath. here's the implementation
```python
from sage.all import *
from Cryptodome.Util.number import *
# Elliptic Curve parameters
p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
a = -3
b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
E = EllipticCurve(Zmod(p), [a,b])

G = E(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5)

B = E(90099139681438884609902890502719410986497907870543013656424398387900610492563, 21444449619346676035849575998271304805253255148709293121336119405905077951856)
c = E(66352599225046789366426989609382550575167780339427460520662466128234215248940, 79145928836074131645330320877947346707491948401697157805655071119445717393612)

# print(B+B)
# print(c+c)

# (46423889747054594922058675350488906208691484528810123715418038177388661249479, 77349316888408695637539425856691344712676691738864096109440661967547740809750 : 1)
# (71348775708023972037009143424101416999169363981150548500107498919238880683568, 49698371443641491375535154691280570201566276348885416658937544761774141192889 : 1)

m = int("24d9b2cb96c8c819840de912e052bfc31549d3abfc3a67c7e7aee3549575698e",16)
m = 16667902361652842058817283456146141523112408649233484459284293323592876517774

# sage: p = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
# sage: a = -3
# sage: b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
# sage: n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
# sage: E = EllipticCurve(GF(p), [a,b])
# sage: m = 16667902361652842058817283456146141523112408649233484459284293323592876517774
# sage: print(E.lift_x(m%p))

M = E(16667902361652842058817283456146141523112408649233484459284293323592876517774, 75475635116653411073496393466925054198245595119229497257308481229642671010680)

# print(M.division_points(2))
print(long_to_bytes(478331744150452007169656202614580135667533560163676060093785159488648061))
```
```
ENO{ElGam4l_1s_mult1pl1cativ3}
```
## Counting 
```
"I heard it is in fashion to have a counter since the last incident happened."
```
we are provided with these attachments <a href="/ignore/nullcon/counting.py">counting</a>
### Solution
this is clearly vulnerable to franklin-reiter attack because we have access to ciphertexts that have a finite constant difference between their plaintext messages. from the following script we can find the secret token 
```python
from sage.all import *
def compositeModulusGCD(a, b):
    if(b == 0):
        return a.monic()
    else:
        return compositeModulusGCD(b, a % b)
def franklinreiter(C1, C2, e, N, a, b):
    x=var('x')
    P = PolynomialRing(Zmod(N),'x')
    gt = a*x + b
    g1 = gt**e - C1
    g2 = x**e - C2
    result = (g1.gcd(g2).coefficients()[0])
    return result
n = 23346864641775135920342683759291067963163772942773308271703099060710413033864481347422098545892696977611932834271295923624466244485288124286513088420414541941384059046912277491270910671335171485310551406049026960803455309802781918134999947913522862009982210925698757778943778254672625452054433259624196304744059442959896711646003841712330244214385219834237537806298533911428744945431606858645010106262556782430228374058268126652399552199171240232565007737391063918608581114239667213495923409397526670860318496015009877207354795886846151279625628512620383849393254056209705916747370652858216859849090288306725458465713
c1 = 5390873336696770499863738064454099629750307690604498397482384952635354976370646962103592174554782442774972636647326721023583942357590609046031691451862593837913348860208415265022628976422090980128578405561603058795408336484451372856600427950574826877436297167027426994052252706079357923629982654698049602565955834717877078281383743452850130796563596961478150737001932442769406611953318998982855333341863117265543896215394478478724650672784569336865243464952090160837560359689798931413538544545266082057437155014071402521667226035188114186901721786854094047461672987974786367938328148862792963925275572485514641747822
c2 = 2018115153376399458061638758898268103529712993646898389562521655366944191753938071967951044760004571520241982280984905339262602363210731257048343440551105584394867593187622084376676680627362864435285943399390109011813972331788670658224518211316210692242094013941517353551391169860896276808310155175606364743718107637109657889780951339209063480488856893226751239692106172871110781341826172447156490108797956695175165816141847505085601917730091481586951673398235006712588670041928054616277484635128806318164131653585140763206166024961647421751004333396447453251727515820792863760404605412404184613836986251050977461299
e = 1337
for i in range(0,2048):
    print(i,end=" ")
    print(franklinreiter(c1,c2,e,n,1,1<<i))
```
which occurs when $i=552$. we can take that secret token and send it back to receive the flag. here's a script using the pwn library to do it
```python
from sage.all import *
from Cryptodome.Util.number import long_to_bytes, bytes_to_long, getPrime, inverse
import sys
import threading
import multiprocessing
from pwn import *
sys.setrecursionlimit(10000)

n = 23346864641775135920342683759291067963163772942773308271703099060710413033864481347422098545892696977611932834271295923624466244485288124286513088420414541941384059046912277491270910671335171485310551406049026960803455309802781918134999947913522862009982210925698757778943778254672625452054433259624196304744059442959896711646003841712330244214385219834237537806298533911428744945431606858645010106262556782430228374058268126652399552199171240232565007737391063918608581114239667213495923409397526670860318496015009877207354795886846151279625628512620383849393254056209705916747370652858216859849090288306725458465713
c1 = 5390873336696770499863738064454099629750307690604498397482384952635354976370646962103592174554782442774972636647326721023583942357590609046031691451862593837913348860208415265022628976422090980128578405561603058795408336484451372856600427950574826877436297167027426994052252706079357923629982654698049602565955834717877078281383743452850130796563596961478150737001932442769406611953318998982855333341863117265543896215394478478724650672784569336865243464952090160837560359689798931413538544545266082057437155014071402521667226035188114186901721786854094047461672987974786367938328148862792963925275572485514641747822
c2 = 2018115153376399458061638758898268103529712993646898389562521655366944191753938071967951044760004571520241982280984905339262602363210731257048343440551105584394867593187622084376676680627362864435285943399390109011813972331788670658224518211316210692242094013941517353551391169860896276808310155175606364743718107637109657889780951339209063480488856893226751239692106172871110781341826172447156490108797956695175165816141847505085601917730091481586951673398235006712588670041928054616277484635128806318164131653585140763206166024961647421751004333396447453251727515820792863760404605412404184613836986251050977461299
e = 1337
a1 = 1
a2 = 1
b1 = 0
check_data = b'\xb8\xf1Z\xd9\x88\x8b\xbb\x17o\x82\xcf2\xa3g\xa3\xdd\x8dx\x11\xe1\xa2\xaa\x02\x85\x1b|\x9b\x07|\xd51\x90-\xf1\x90\xcf\x14K[~\x8anO\xda\xce\x0ei_=\x16\x15\x9188\xc11A\xe4\x13\x84\xd7\x9f\xd5\xd0\xf1t\xac\xfb>\xf3\xdc\xf4/\xe5\x7f\x0cW\xf3z]\x91\x022\x83k\x8bu\xd7\x82\x84+\xce1\x90\xba\xe6m\x8b\xc73\x8b+\x04\xe4\xed\xd6\xfa\xdd\x19\xe8\xa1"\xbd\n\xbb"\xccW\xe7\xa1@\xef\x9a\x1a\x97\x0f\x87\xc9h4\xa9q\x15\xc4\xde8\r\x1c\x98S\x81\x16\xed\x01\xf9+\xd0\xad\xe9q\xfd\xa5Z\xce\xb6\x15h\xc7\x17\xe2\x80/\x9cIBRK\x10\xf5#\xf0|\xed\x06\xa3\xd3\xe7\xac\xde\xb3\xa1\xa6m@\xa2D\x11\x85|\x8f\xf2\xbe\xb6\x07 \xb5\xa8"8wL\xe4\x9f\xd0\x06\x89Y\x17 \x80H"\xe6\x9c;\xc8\x04\x0c\xa6\xb0\xda\x03?5/\xda\xc3\xf6\t^\xd8\x1a\x82"\xeb\xea\xdf\xea\xff\x14\xdb\xff(\xdd\x03\xff8\xcb\x84W\x9f\xc2\x1a\x16\xd3\xb0'
def compositeModulusGCD(a, b):
    if(b == 0):
            return a.monic()
    else:
            return compositeModulusGCD(b, a % b)

def FranklinReiter(n, e, c1, c2, a1, a2, b1, b2):
    x = var('x')
    P = PolynomialRing(Zmod(n),'x')
    f = (a1*P('x')+b1)**e - c1
    g = (a2*P('x')+b2)**e - c2
    m =  Integer(n-(compositeModulusGCD(f,g)).coefficients()[0])
    data = long_to_bytes(m)
    return data
def attack(i):
    for k in range(i,i+50):
        FranklinReiter(n, e, c1, c2, a1, a2, b1, 1<<k)
        print(k)
        print()
# k = 552 

p = remote("52.59.124.14", 10008)
p.recvline()
n = int(p.recvline().strip().decode())
p.recvline()
c1 = int(p.recvline().strip().decode())
p.recvline()
p.sendline(b'0')

c2 = int(p.recvline().strip().decode())

# threads=[]
# for j in range(1, 20):
#     t=multiprocessing.Process(target=attack, args=[50*j])
#     t.start()
#     threads.append(t)
# for thread in threads:
#     thread.join()

data = FranklinReiter(n, e, c1, c2, a1, a2, b1, 1<<552)
#print(data)
data = data.lstrip(b"So far we had 000 failed attempts to find the token ")

p.recvline()
p.sendline(data)
p.interactive()
```
```
ENO{th3_s0lut1on_i5_n0t_th4t_1337}
```
## PS
```
"I prepared a message for Alice but if you'd like to add a PS of your own, feel free to do so."
```
and we are given the following <a href="/ignore/nullcon/ps.py">ps</a>
### Solution
this is directly vulnerable to coppersmith's short pad attack. you just need two ciphertexts that correspond to the same message and regardless of the padding involved, it's possible to retrieve the original plaintext. here's an implementation
```python
from sage.all import *
from Cryptodome.Util.number import *

e = 3
C1 = 18800481586084054039791866260340290530753574096608981219676240952396581215405999322900721100010143358589565875849265244891390128879142073674638014692781954038221076142575211160056045982796570456403342235459993226189711527512562549524264843084507825543946345870421929944088320180203523639015697492701408889457323728338550507083486875200308148796204028203570173287676527573646603945419970064235111825693068356464405802301158513683267018997412021868567192325479277994301600670226202801507297712203287915189024886419741595336452702129004648312156111491929387084173480767829508241603972024562685845159300712087467222972414
C2 = 19375006589171030326270617776231319324969029997139315115971109313589384847707485912573635123105574546651501400856186750907392226426743246244844372523424939628305483513585296877402825398903499062054803711306626890999374850577720075170496140618617379075078391437704503410338992789043268728325948976627000155399277977268925034878255324440837146428195184999176537456410639262680328985352536726067199177612341409065569671215712743433744648762545218549706125273512202243892688650026737516892504551133680758510886374359545609402020273859001567227723040602078391881582529395269652598167994891548852568011906719668214126909718
n = 21978670871762945557634799190721314141794311091517242394558844124687851054277684977037028285786822192262995195418294773668940700468164482573543705594853486972766736778488106596396992068727783704724965242058757992489409567475726919993756608522406732756132040771825195203510136574018630806796666291202619128663626521114169177613809934932801796890467573044639957689104645015765413438097264364884918312631529069998729397206541065171048187371912170223579228639283775790801444836744079377468645817916865296038218066985848492440248584475887489111754378975909611961609948443207914186884037771474651660846036152336893402549599

# sage: def short_pad_attack(c1, c2, e, n):
#     PRxy.<x,y> = PolynomialRing(Zmod(n))
#     PRx.<xn> = PolynomialRing(Zmod(n))
#     PRZZ.<xz,yz> = PolynomialRing(Zmod(n))
#     g1 = x^e - c1
#     g2 = (x+y)^e - c2
#     q1 = g1.change_ring(PRZZ)
#     q2 = g2.change_ring(PRZZ)
#     h = q2.resultant(q1)
#     h = h.univariate_polynomial()
#     h = h.change_ring(PRx).subs(y=xn)
#     h = h.monic()
#     diff = h.small_roots(X=2**128, beta=0.3)[0]  # find root < 2^kbits with factor >= n^0.5
#     return diff
# sage: e = 3
# sage: C1 = 18800481586084054039791866260340290530753574096608981219676240952396581215405999322900721100010143358589565875849265244891390128879142073674638014692781954038221076142575211160056045982796570456403342235459993226189711527512562549524264843084507825543946345870421929944088320180203523639015697492701408889457323728338550507083486875200308148796204028203570173287676527573646603945419970064235111825693068356464405802301158513683267018997412021868567192325479277994301600670226202801507297712203287915189024886419741595336452702129004648312156111491929387084173480767829508241603972024562685845159300712087467222972414
# sage: C2 = 19375006589171030326270617776231319324969029997139315115971109313589384847707485912573635123105574546651501400856186750907392226426743246244844372523424939628305483513585296877402825398903499062054803711306626890999374850577720075170496140618617379075078391437704503410338992789043268728325948976627000155399277977268925034878255324440837146428195184999176537456410639262680328985352536726067199177612341409065569671215712743433744648762545218549706125273512202243892688650026737516892504551133680758510886374359545609402020273859001567227723040602078391881582529395269652598167994891548852568011906719668214126909718
# sage: n = 21978670871762945557634799190721314141794311091517242394558844124687851054277684977037028285786822192262995195418294773668940700468164482573543705594853486972766736778488106596396992068727783704724965242058757992489409567475726919993756608522406732756132040771825195203510136574018630806796666291202619128663626521114169177613809934932801796890467573044639957689104645015765413438097264364884918312631529069998729397206541065171048187371912170223579228639283775790801444836744079377468645817916865296038218066985848492440248584475887489111754378975909611961609948443207914186884037771474651660846036152336893402549599
# sage: diff = short_pad_attack(C1,C2,e,n)
# sage: print(diff)

# output: 21978670871762945557634799190721314141794311091517242394558844124687851054277684977037028285786822192262995195418294773668940700468164482573543705594853486972766736778488106596396992068727783704724965242058757992489409567475726919993756608522406732756132040771825195203510136574018630806796666291202619128663626521114169177613809934932801796890467573044639957689104645015765413438097264364884918312631529069998729397206541065171048187371912170223579228639283775790801444836744079377468645817916865296038218066985848492440248584475887489111754378975909611961609948443207914186883847205603555784402932177378485299990661
diff = 21978670871762945557634799190721314141794311091517242394558844124687851054277684977037028285786822192262995195418294773668940700468164482573543705594853486972766736778488106596396992068727783704724965242058757992489409567475726919993756608522406732756132040771825195203510136574018630806796666291202619128663626521114169177613809934932801796890467573044639957689104645015765413438097264364884918312631529069998729397206541065171048187371912170223579228639283775790801444836744079377468645817916865296038218066985848492440248584475887489111754378975909611961609948443207914186883847205603555784402932177378485299990661

def compositeModulusGCD(a, b):
    if(b == 0):
            return a.monic()
    else:
            return compositeModulusGCD(b, a % b)

def FranklinReiter(n, e, c1, c2, a1, a2, b1, b2):
    x = var('x')
    P = PolynomialRing(Zmod(n),'x')
    f = (a1*P('x')+b1)**e - c1
    g = (a2*P('x')+b2)**e - c2
    m =  Integer(n-(compositeModulusGCD(f,g)).coefficients()[0])
    return m

m = FranklinReiter(n, e, C1, C2, 1, 1, 0, diff)
M1 = long_to_bytes(m)
M2 = long_to_bytes(m+diff)
print(M1)
```
```
ENO{we11_5eem5_lik3_128_r4ndom_b1ts_4r3_n0t_3n0ugh}
```
